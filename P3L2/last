// ================================================
// ADVANCED_ENUMERABLE_TASKS_PART2.cs
// Dodatkowe warianty i helpery (Chunk, TopNWithTies, BuildFromParentArray, sliding-window variants).
// Gotowe do skopiowania do projektu.
// Źródła / inspiracje: MoreLINQ examples, GeeksForGeeks array-tree, sliding-window SO threads.
// See: MoreLINQ examples, GeeksForGeeks binary-tree-array, SO Sliding Window. :contentReference[oaicite:1]{index=1}
// ================================================

using System;
using System.Collections.Generic;
using System.Linq;

public static class AdvancedEnumerableTasks2
{
    // ---------------------------
    // 1) Chunk polyfill (for .NET < 6)
    //    Splits sequence into chunks of given size, last chunk may be shorter.
    //    Inspired by C# Chunk semantics (available in .NET 6+).
    // ---------------------------
    public static IEnumerable<T[]> ChunkPolyfill<T>(this IEnumerable<T> source, int size)
    {
        if (source == null) throw new ArgumentNullException(nameof(source));
        if (size <= 0) throw new ArgumentOutOfRangeException(nameof(size));
        using var e = source.GetEnumerator();
        while (e.MoveNext())
        {
            var arr = new T[size];
            int i = 0;
            arr[i++] = e.Current;
            for (; i < size && e.MoveNext(); i++)
                arr[i] = e.Current;
            if (i == size) yield return arr;
            else
            {
                // shrink the array to actual size
                var outArr = new T[i];
                Array.Copy(arr, outArr, i);
                yield return outArr;
            }
        }
    }

    // ---------------------------
    // 2) TopNWithTies generic helper
    //    Returns sequence of items that belong to top-N groups by key,
    //    including all items tied with the N-th group's size.
    //    Useful for "top 3 including ties" tasks. (See SO discussion). :contentReference[oaicite:2]{index=2}
    // ---------------------------
    public static IEnumerable<TItem> TopNWithTies<TItem, TKey>(this IEnumerable<TItem> items, Func<TItem, TKey> groupKeySelector, int n)
    {
        if (items == null) throw new ArgumentNullException(nameof(items));
        if (groupKeySelector == null) throw new ArgumentNullException(nameof(groupKeySelector));
        if (n <= 0) throw new ArgumentOutOfRangeException(nameof(n));

        var groups = items.GroupBy(groupKeySelector)
                          .Select(g => new { Key = g.Key, Count = g.Count(), Items = g.ToList() })
                          .OrderByDescending(g => g.Count)
                          .ToList();

        if (!groups.Any()) yield break;

        var top = groups.Take(n).ToList();
        int threshold = top.Last().Count;
        foreach (var g in groups.Where(g => g.Count >= threshold))
            foreach (var it in g.Items)
                yield return it;
    }

    // ---------------------------
    // 3) Build array-backed tree from parent[] representation (GeeksForGeeks style)
    //    parent[i] = parent index of node i, root has parent -1.
    //    We build a sparse array-backed representation (Dictionary) to avoid huge arrays.
    // ---------------------------
    public class SparseArrayBinaryTree<T>
    {
        private readonly Dictionary<int, T> _dict = new();

        public bool Exists(int i) => _dict.ContainsKey(i);
        public T Get(int i) => _dict[i];
        public void Set(int i, T value) => _dict[i] = value;

        public void SetLeftChild(int parent, T value) => _dict[2 * parent + 1] = value;
        public void SetRightChild(int parent, T value) => _dict[2 * parent + 2] = value;

        public IEnumerable<(int Index, T Value)> DumpExisting() => _dict.Select(kv => (kv.Key, kv.Value));
    }

    public static SparseArrayBinaryTree<int> BuildSparseTreeFromParentArray(int[] parent)
    {
        // Simple heuristic assignment: for each node i, assign it to first free child slot of parent
        var tree = new SparseArrayBinaryTree<int>();
        for (int i = 0; i < parent.Length; i++)
        {
            int p = parent[i];
            if (p == -1)
            {
                tree.Set(i, i); // root stored at its index
                continue;
            }
            int left = 2 * p + 1;
            if (!tree.Exists(left)) tree.Set(left, i);
            else tree.Set(2 * p + 2, i);
        }
        return tree;
    }

    // ---------------------------
    // 4) Sliding window variant: left-aligned windows with step and optional padding
    //    (MoreLINQ-like behavior; handles step>1, pad with default if requested)
    // ---------------------------
    public static IEnumerable<T[]> SlidingWindowVariant<T>(this IEnumerable<T> source, int size, int step = 1, bool padWithDefault = false)
    {
        if (source == null) throw new ArgumentNullException(nameof(source));
        if (size < 1) throw new ArgumentOutOfRangeException(nameof(size));
        if (step < 1) throw new ArgumentOutOfRangeException(nameof(step));

        var q = new Queue<T>(size);
        using var e = source.GetEnumerator();

        while (e.MoveNext())
        {
            q.Enqueue(e.Current);
            if (q.Count > size) q.Dequeue();
            if (q.Count == size)
                yield return q.ToArray();

            // advance (step-1) elements pre-consumption
            for (int i = 1; i < step && e.MoveNext(); i++)
            {
                q.Enqueue(e.Current);
                if (q.Count > size) q.Dequeue();
                if (q.Count == size) yield return q.ToArray();
            }
        }

        if (q.Count > 0 && q.Count < size && padWithDefault)
        {
            var tmp = q.ToArray().ToList();
            while (tmp.Count < size) tmp.Add(default!);
            yield return tmp.ToArray();
        }
    }

    // ---------------------------
    // 5) Windowed median (naive example): maintain sorted window using List<T> -> O(k log k) per slide
    //    (Good for small windows; for large windows use two-heaps technique)
    // ---------------------------
    public static IEnumerable<double> SlidingMedianNaive(this IEnumerable<int> source, int windowSize)
    {
        if (windowSize < 1) throw new ArgumentOutOfRangeException(nameof(windowSize));
        var window = new List<int>();
        using var e = source.GetEnumerator();
        while (e.MoveNext())
        {
            window.Add(e.Current);
            if (window.Count > windowSize) window.RemoveAt(0);
            if (window.Count == windowSize)
            {
                var sorted = window.ToList();
                sorted.Sort();
                int mid = sorted.Count / 2;
                double median = (sorted.Count % 2 == 1) ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2.0;
                yield return median;
            }
        }
    }

    // ---------------------------
    // 6) Pairwise and AdjacentDiffs helpers (common interview snippets)
    // ---------------------------
    public static IEnumerable<(T Prev, T Curr)> PairwiseGeneric<T>(this IEnumerable<T> source)
    {
        using var e = source.GetEnumerator();
        if (!e.MoveNext()) yield break;
        T prev = e.Current;
        while (e.MoveNext())
        {
            yield return (prev, e.Current);
            prev = e.Current;
        }
    }

    public static IEnumerable<TResult> AdjacentDifferences<T, TResult>(this IEnumerable<T> source, Func<T, T, TResult> mapper)
    {
        foreach (var p in source.PairwiseGeneric())
            yield return mapper(p.Prev, p.Curr);
    }

    // ---------------------------
    // 7) Example: TopN movies by rating count (glue code using TopNWithTies)
    // ---------------------------
    // Given a ratings list of (MovieId, Score), return MovieId top N including ties
    public static IEnumerable<int> TopNMovieIdsByRatingCount(IEnumerable<(int MovieId, int Score)> ratings, int topN)
    {
        // group into items of MovieId and use TopNWithTies
        var movieIds = ratings.Select(r => r.MovieId);
        // Note: TopNWithTies expects items grouped by a key; here, item is movieId itself so key=item
        return movieIds.TopNWithTies(id => id, topN).Distinct();
    }

    // ---------------------------
    // 8) Utility: sliding-window sums using circular buffer (efficient)
    // ---------------------------
    public static IEnumerable<long> SlidingWindowSumEfficient(this IEnumerable<int> source, int size)
    {
        if (size <= 0) throw new ArgumentOutOfRangeException(nameof(size));
        var buffer = new int[size];
        int head = 0, count = 0;
        long sum = 0;
        foreach (var x in source)
        {
            if (count < size)
            {
                buffer[head++] = x;
                sum += x;
                count++;
                if (head == size) head = 0;
                if (count == size) yield return sum;
            }
            else
            {
                // overwrite oldest
                int oldestIndex = head;
                sum -= buffer[oldestIndex];
                buffer[oldestIndex] = x;
                sum += x;
                head++; if (head == size) head = 0;
                yield return sum;
            }
        }
    }
}

// ================================================
// Example usage / quick manual tests
// ================================================
public static class AdvancedEnumerableTasks2Demo
{
    public static void Run()
    {
        var seq = Enumerable.Range(1, 10).ToList();

        Console.WriteLine(\"ChunkPolyfill (size=3):\");
        foreach (var c in seq.ChunkPolyfill(3))
            Console.WriteLine(\"[\" + string.Join(\",\", c) + \"]\");

        Console.WriteLine(\"\\nTopNWithTies example (group counts):\");
        var items = new[] { 1,1,1,2,2,3,3,4 }; // counts: 1->3, 2->2, 3->2, 4->1
        var top = items.TopNWithTies(x=>x, 2); // top2 groups: counts 3 and 2 => threshold=2 => returns items for groups 1,2,3
        Console.WriteLine(string.Join(\",\", top.Distinct()));

        Console.WriteLine(\"\\nSlidingWindowVariant(size=3, step=2):\");
        foreach (var w in seq.SlidingWindowVariant(3, 2))
            Console.WriteLine(\"[\" + string.Join(\",\", w) + \"]\");

        Console.WriteLine(\"\\nSlidingMedianNaive (window=3):\");
        foreach (var m in seq.SlidingMedianNaive(3))
            Console.WriteLine(m);

        Console.WriteLine(\"\\nSlidingWindowSumEfficient (size=4):\");
        foreach (var s in seq.SlidingWindowSumEfficient(4))
            Console.WriteLine(s);

        Console.WriteLine(\"\\nBuildSparseTreeFromParentArray example:\");
        int[] parent = new int[] { -1, 0, 0, 1, 1, 2, 2 };
        var tree = AdvancedEnumerableTasks2.BuildSparseTreeFromParentArray(parent);
        foreach (var p in tree.DumpExisting())
            Console.WriteLine($\"idx={p.Index}, val={p.Value}\");
    }
}
