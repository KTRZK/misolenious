using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using ExamMaterials.DataStructures; // reference to tree templates if needed

// EXAM_VARIANT: DatabaseQueries.Base
// Purpose: base implementations and configurable variants for the Movie Database LINQ tasks.
// NOTE: If you already have DatabaseQueries implemented from the provided assignments,
//       treat this file as an extended toolkit: it contains safe, well-commented query patterns,
//       multiple policy variants, EXAM_CONFIG toggles and helper snippets intended for quick exam edits.

namespace ExamMaterials.Movies
{
    public interface IMovieDatabase
    {
        List<Movie> Movies { get; }
        List<Actor> Actors { get; }
        List<Rating> Ratings { get; }
        List<Cast> Casts { get; }
    }

    public static class DatabaseQueries
    {
        // EXAM_CONFIG: global parameters you can change quickly during the exam
        public const int RatingThresholdDefault = 8;
        public const int RecentYearsDefault = 5;
        public static DateTime? ReferenceDate = null; // if null -> DateTime.Now; set to fixed date for deterministic tests
        public const int TopNDefault = 3;
        public const bool IncludeTiesInTopN = false; // when true, TopN returns ties as well

        #region Display helper
        public static void DisplayQueryResults<T>(T query)
        {
            var options = new JsonSerializerOptions
            {
                WriteIndented = true
            };

            options.Converters.Add(new JsonStringEnumConverter());

            var json = JsonSerializer.Serialize(query, options);

            Console.WriteLine(json);
        }
        #endregion

        #region Query helpers (common patterns)
        // Build lookup dictionaries to speed up joins in large datasets
        private static Dictionary<int, Movie> MoviesById(IMovieDatabase db) => db.Movies.ToDictionary(m => m.Id);
        private static Dictionary<int, Actor> ActorsById(IMovieDatabase db) => db.Actors.ToDictionary(a => a.Id);

        // Safe average: returns nullable double if sequence empty
        private static double? SafeAverage(IEnumerable<int> seq)
        {
            if (seq == null) return null;
            var any = seq.Any();
            return any ? seq.Average() : (double?)null;
        }

        // TopN including ties pattern
        private static IEnumerable<TResult> TopNWithTies<TSource, TKey, TResult>(IEnumerable<TSource> items,
            Func<TSource, TKey> keySelector,
            Func<IGrouping<TKey, TSource>, TResult> projector,
            int n) where TKey : IComparable
        {
            var groups = items.GroupBy(keySelector)
                              .OrderByDescending(g => g.Count())
                              .ToList();
            if (!groups.Any()) return Enumerable.Empty<TResult>();

            var top = groups.Take(n).ToList();
            if (groups.Count <= n) return top.Select(projector);

            int threshold = top.Last().Count();
            return groups.Where(g => g.Count() >= threshold).Select(projector);
        }
        #endregion

        #region Query 1: Actors from Fantasy Movies (variants)
        // Default: return List<Actor>
        public static void ActorsFromFantasyMovies(this IMovieDatabase movieDatabase, Genre filterGenre = Genre.Fantasy)
        {
            // Use a join between casts and movies (filtered), distinct actorIds, then join to actors.
            var movies = movieDatabase.Movies;
            var actors = movieDatabase.Actors;
            var casts = movieDatabase.Casts;

            var queryResult = casts
                .Join(movies.Where(m => m.Genre == filterGenre),
                      cast => cast.MovieId,
                      movie => movie.Id,
                      (cast, movie) => cast.ActorId)
                .Distinct()
                .Join(actors,
                      actorId => actorId,
                      actor => actor.Id,
                      (actorId, actor) => actor)
                .ToList();

            Console.WriteLine($"Actors From {filterGenre} Movies");
            DisplayQueryResults(queryResult);
            Console.WriteLine();
        }
        #endregion

        #region Query 2: Longest movie by genre
        // Default: return one movie per genre (first encountered when multiple tie)
        public static void LongestMovieByGenre(this IMovieDatabase movieDatabase)
        {
            var movies = movieDatabase.Movies;

            var queryResult = movies
                .GroupBy(m => m.Genre)
                .Select(g => new
                {
                    Genre = g.Key,
                    Movie = g.OrderByDescending(m => m.DurationMinutes).FirstOrDefault()
                })
                .ToList();

            Console.WriteLine("Longest Movie By Genre");
            DisplayQueryResults(queryResult);
            Console.WriteLine();
        }

        // Variant: return all movies that tie for maximum length per genre
        public static void LongestMoviesByGenre_AllTies(this IMovieDatabase movieDatabase)
        {
            var movies = movieDatabase.Movies;

            var queryResult = movies
                .GroupBy(m => m.Genre)
                .Select(g => new
                {
                    Genre = g.Key,
                    MaxDuration = g.Max(m => m.DurationMinutes),
                    Movies = g.Where(m => m.DurationMinutes == g.Max(x => x.DurationMinutes)).ToList()
                })
                .ToList();

            Console.WriteLine("Longest Movies By Genre (all ties)");
            DisplayQueryResults(queryResult);
            Console.WriteLine();
        }
        #endregion

        #region Query 3: High rated movies with cast
        public static void HighRatedMoviesWithCast(this IMovieDatabase movieDatabase, int threshold = RatingThresholdDefault)
        {
            var movies = movieDatabase.Movies;
            var actors = movieDatabase.Actors;
            var ratings = movieDatabase.Ratings;
            var casts = movieDatabase.Casts;

            var movieAverages = ratings
                .GroupBy(r => r.MovieId)
                .Select(g => new { MovieId = g.Key, Average = g.Average(r => r.Score) })
                .Where(x => x.Average > threshold)
                .ToList();

            var result = movieAverages
                .Join(movies, r => r.MovieId, m => m.Id, (r, m) => new { Movie = m, r.Average })
                .GroupJoin(casts, m => m.Movie.Id, c => c.MovieId, (m, cs) => new
                {
                    m.Movie,
                    m.Average,
                    CastIds = cs.Select(c => c.ActorId)
                })
                .Select(x => new
                {
                    x.Movie,
                    x.Average,
                    Cast = x.CastIds.Join(actors, id => id, a => a.Id, (id, a) => a).ToList()
                })
                .ToList();

            Console.WriteLine($"High Rated Movies With Cast (avg > {threshold})");
            DisplayQueryResults(result);
            Console.WriteLine();
        }
        #endregion

        #region Query 4: Distinct roles count per actor
        public static void DistinctRolesCountPerActor(this IMovieDatabase movieDatabase)
        {
            var actors = movieDatabase.Actors;
            var casts = movieDatabase.Casts;

            var queryResult = actors
                .GroupJoin(casts, actor => actor.Id, cast => cast.ActorId,
                    (actor, actorCasts) => new
                    {
                        Actor = actor,
                        Roles = actorCasts.Select(c => c.Role).Distinct().Count()
                    })
                .OrderByDescending(x => x.Roles)
                .ToList();

            Console.WriteLine("Distinct Roles Count Per Actor");
            DisplayQueryResults(queryResult);
            Console.WriteLine();
        }
        #endregion

        #region Query 5: Recent movies with average rating
        public static void RecentMoviesWithAverageRating(this IMovieDatabase movieDatabase, int pastYears = RecentYearsDefault)
        {
            var movies = movieDatabase.Movies;
            var ratings = movieDatabase.Ratings;

            var refDate = ReferenceDate ?? DateTime.Now;
            var thresholdYear = refDate.Year - pastYears;

            var result = movies
                .Where(m => m.Year > thresholdYear)
                .GroupJoin(ratings, m => m.Id, r => r.MovieId,
                    (m, rr) => new
                    {
                        Movie = m,
                        AverageScore = rr.Any() ? rr.Average(x => x.Score) : 0.0
                    })
                .OrderByDescending(x => x.AverageScore)
                .ToList();

            Console.WriteLine($"Recent Movies With Average Rating (last {pastYears} years relative to {refDate.Date.ToShortDateString()})");
            DisplayQueryResults(result);
            Console.WriteLine();
        }
        #endregion

        #region Query 6: Average rating by genre
        public static void AverageRatingByGenre(this IMovieDatabase movieDatabase)
        {
            var movies = movieDatabase.Movies;
            var ratings = movieDatabase.Ratings;

            var queryResult = ratings
                .Join(movies, rating => rating.MovieId, movie => movie.Id,
                      (rating, movie) => new { movie.Genre, rating.Score })
                .GroupBy(x => x.Genre)
                .Select(g => new { Genre = g.Key, AverageScore = g.Select(x => x.Score).Average() })
                .ToList();

            Console.WriteLine("Average Rating By Genre");
            DisplayQueryResults(queryResult);
            Console.WriteLine();
        }
        #endregion

        #region Query 7: Actors who never played in Thriller
        public static void ActorsWhoNeverPlayedInThriller(this IMovieDatabase movieDatabase, Genre thrillerGenre = Genre.Thriller)
        {
            var movies = movieDatabase.Movies;
            var casts = movieDatabase.Casts;
            var actors = movieDatabase.Actors;

            var thrillerIds = movies.Where(m => m.Genre == thrillerGenre).Select(m => m.Id).ToHashSet();
            var thrillerActors = casts.Where(c => thrillerIds.Contains(c.MovieId)).Select(c => c.ActorId).ToHashSet();

            var queryResult = actors.Where(a => !thrillerActors.Contains(a.Id)).ToList();

            Console.WriteLine("Actors Who Never Played In Thriller");
            DisplayQueryResults(queryResult);
            Console.WriteLine();
        }
        #endregion

        #region Query 8: Top N movies by rating count
        public static void TopNMoviesByRatingCount(this IMovieDatabase movieDatabase, int topN = TopNDefault, bool includeTies = IncludeTiesInTopN)
        {
            var movies = movieDatabase.Movies;
            var ratings = movieDatabase.Ratings;

            var groups = ratings.GroupBy(r => r.MovieId).Select(g => new { MovieId = g.Key, Count = g.Count() }).ToList();
            if (!groups.Any())
            {
                Console.WriteLine("Top movies by rating count: no ratings found");
                return;
            }

            var ordered = groups.OrderByDescending(g => g.Count).ToList();
            if (!includeTies)
            {
                var top = ordered.Take(topN).Select(g => movies.First(m => m.Id == g.MovieId)).ToList();
                DisplayQueryResults(top);
            }
            else
            {
                var topGroups = ordered.Take(topN).ToList();
                var threshold = topGroups.Last().Count;
                var topWithTies = ordered.Where(g => g.Count >= threshold).Select(g => movies.First(m => m.Id == g.MovieId)).ToList();
                DisplayQueryResults(topWithTies);
            }

            Console.WriteLine();
        }
        #endregion

        #region Query 9: Movies without ratings
        public static void MoviesWithoutRatings(this IMovieDatabase movieDatabase)
        {
            var movies = movieDatabase.Movies;
            var ratings = movieDatabase.Ratings;

            var queryResult = movies
                .GroupJoin(ratings, m => m.Id, r => r.MovieId, (m, rr) => new { Movie = m, HasRatings = rr.Any() })
                .Where(x => !x.HasRatings)
                .Select(x => x.Movie)
                .ToList();

            Console.WriteLine("Movies Without Ratings");
            DisplayQueryResults(queryResult);
            Console.WriteLine();
        }
        #endregion

        #region Query 10: Most versatile actors
        public static void MostVersatileActors(this IMovieDatabase movieDatabase)
        {
            var movies = movieDatabase.Movies;
            var actors = movieDatabase.Actors;
            var casts = movieDatabase.Casts;

            var queryResult = casts
                .Join(movies, c => c.MovieId, m => m.Id, (c, m) => new { c.ActorId, m.Genre })
                .GroupBy(x => x.ActorId)
                .Select(g => new { ActorId = g.Key, GenreCount = g.Select(x => x.Genre).Distinct().Count() })
                .Join(actors, x => x.ActorId, a => a.Id, (x, a) => new { Actor = a, x.GenreCount })
                .OrderByDescending(x => x.GenreCount)
                .ToList();

            Console.WriteLine("Most Versatile Actors");
            DisplayQueryResults(queryResult);
            Console.WriteLine();
        }
        #endregion

        #region Extra utility queries and variants (snippets)
        // EXAM_SNIPPETS: ready-to-copy variants
        // - Weighted average by decay (example)
        // - TopNWithTies as separate utility
        // - Returning DTO vs anonymous type

        // Example: Weighted average where newer ratings count more
        public static double WeightedAverageByRecency(IEnumerable<Rating> ratings, DateTime referenceDate)
        {
            // simple exponential decay weight: w = e^{-lambda * days}
            const double lambda = 0.01; // EXAM_CONFIG could expose this
            var weighted = ratings.Select(r => new { r.Score, Weight = Math.Exp(-lambda * (referenceDate - r.CreatedAt).TotalDays) });
            var sumWeights = weighted.Sum(x => x.Weight);
            if (sumWeights == 0) return 0.0;
            return weighted.Sum(x => x.Score * x.Weight) / sumWeights;
        }
        #endregion
    }
}


using System;
using System.Collections.Generic;
using System.Linq;

namespace Lab2_RepoTraversal
{
    // Reprezentacja commita
    public class Commit
    {
        public string Hash { get; }
        public List<string> ParentHashes { get; }

        public Commit(string hash, IEnumerable<string> parents = null)
        {
            Hash = hash;
            ParentHashes = parents?.ToList() ?? new List<string>();
        }
    }

    // Prosty model repozytorium
    public class Repository
    {
        // obiekty przechowywane pod skrótami (commity)
        public Dictionary<string, Commit> Objects { get; } = new Dictionary<string, Commit>();

        // gałęzie: nazwa -> skrót obiektu
        public Dictionary<string, string> Branches { get; } = new Dictionary<string, string>();

        // HEAD wskazany jako skrót
        public string HEAD { get; set; }

        // --- metody wymagane przez zadanie ---
        public bool TryGetCommit(string hash, out Commit commit)
        {
            if (hash == null) { commit = null; return false; }
            return Objects.TryGetValue(hash, out commit);
        }

        public Commit GetCommitOrThrow(string hash)
        {
            if (!TryGetCommit(hash, out var commit))
                throw new InvalidOperationException($"Commit '{hash}' not found");
            return commit;
        }

        // Traverse po pierwszych rodzicach (first parent)
        public IEnumerable<Commit> TraverseBranchByFirstParent(string startHash = null)
        {
            var start = startHash ?? HEAD;
            if (start == null)
                yield break;

            var currentHash = start;
            while (true)
            {
                if (!TryGetCommit(currentHash, out var current))
                    throw new InvalidOperationException($"Commit '{currentHash}' not found");

                yield return current;

                if (current.ParentHashes.Count == 0)
                    yield break;

                // idziemy po pierwszym rodzicu
                currentHash = current.ParentHashes[0];
            }
        }

        // TraverseByRevision zgodnie z patternem Revision (zwraca lazy IEnumerable<Commit>)
        public IEnumerable<Commit> TraverseByRevision(string pattern)
        {
            var rev = Revision.Parse(pattern);

            // 1. Rozwiąż BaseRef -> daje sekwencję skrótów (zwykle pojedynczy element)
            IEnumerable<string> hashes = ResolveBaseRefToHashes(rev.BaseRef);
            // 2. Zastosuj kolejno modyfikatory
            foreach (var mod in rev.Modifiers)
            {
                hashes = mod.Apply(this, hashes);
            }

            // 3. Pobierz obiekty z repo i zwróć je (leniwie)
            foreach (var h in hashes)
            {
                yield return GetCommitOrThrow(h);
            }
        }

        private IEnumerable<string> ResolveBaseRefToHashes(string baseRef)
        {
            if (string.IsNullOrEmpty(baseRef))
                throw new InvalidOperationException("Base reference not provided");

            // jeżeli BaseRef to HEAD
            if (baseRef == "HEAD")
            {
                if (HEAD == null)
                    throw new InvalidOperationException("Base reference not found");
                yield return HEAD;
                yield break;
            }

            // jeżeli jest nazwą gałęzi
            if (Branches.TryGetValue(baseRef, out var branchHash))
            {
                yield return branchHash;
                yield break;
            }

            // jeżeli jest bezpośrednim skrótem w objects
            if (Objects.ContainsKey(baseRef))
            {
                yield return baseRef;
                yield break;
            }

            throw new InvalidOperationException("Base reference not found");
        }
    }

    // Interfejs modyfikatora Revision (Apply przyjmuje repo i kolekcję hashy, zwraca kolekcję hashy)
    public interface IRevisionModifier
    {
        IEnumerable<string> Apply(Repository repo, IEnumerable<string> inputHashes);
    }

    // ^N  => ParentIndexModifier
    // ^  (bez liczby) traktujemy jako ^1 (pierwszy rodzic)
    public class ParentIndexModifier : IRevisionModifier
    {
        public int Index { get; } // 1-based index

        public ParentIndexModifier(int index = 1)
        {
            if (index <= 0) throw new ArgumentException("Parent index must be positive");
            Index = index;
        }

        public IEnumerable<string> Apply(Repository repo, IEnumerable<string> inputHashes)
        {
            foreach (var h in inputHashes)
            {
                var commit = repo.GetCommitOrThrow(h);
                if (commit.ParentHashes.Count == 0)
                    throw new InvalidOperationException($"Commit '{h}' has no parent");

                // parent index is 1-based; if index > count -> error "does not have parent #{index}"
                if (Index > commit.ParentHashes.Count)
                    throw new InvalidOperationException($"Commit '{h}' does not have parent #{Index}");

                yield return commit.ParentHashes[Index - 1];
            }
        }
    }

    // ~N => AncestorCountModifier: cofa N razy po pierwszym rodzicu (domyślnie ~ = ~1)
    public class AncestorCountModifier : IRevisionModifier
    {
        public int Count { get; }

        public AncestorCountModifier(int count = 1)
        {
            if (count < 0) throw new ArgumentException("Count must be non-negative");
            Count = count;
        }

        public IEnumerable<string> Apply(Repository repo, IEnumerable<string> inputHashes)
        {
            foreach (var h in inputHashes)
            {
                var currentHash = h;
                Commit current = repo.GetCommitOrThrow(currentHash);
                int steps = Count;
                while (steps-- > 0)
                {
                    if (current.ParentHashes.Count == 0)
                        throw new InvalidOperationException($"Commit '{current.Hash}' has no parent");
                    var nextHash = current.ParentHashes[0];
                    current = repo.GetCommitOrThrow(nextHash);
                }
                yield return current.Hash;
            }
        }
    }

    // Klasa reprezentująca sparsowany pattern (np. HEAD~3^2~1)
    public class Revision
    {
        public string BaseRef { get; }
        public List<IRevisionModifier> Modifiers { get; }

        private Revision(string baseRef, IEnumerable<IRevisionModifier> modifiers)
        {
            BaseRef = baseRef;
            Modifiers = modifiers?.ToList() ?? new List<IRevisionModifier>();
        }

        // Parser prostego wzorca: BaseRef (hash|branch|HEAD) (('~'N?) | ('^'N?))* 
        // ~N : N domyślnie 1
        // ^N : N domyślnie 1 (oznacza numer rodzica, 1-based)
        public static Revision Parse(string pattern)
        {
            if (string.IsNullOrWhiteSpace(pattern))
                throw new ArgumentException("Pattern must not be empty");

            int i = 0;
            int len = pattern.Length;

            // czytamy BaseRef jako ciąg znaków do pierwszego ^ lub ~ lub końca
            int start = i;
            while (i < len && pattern[i] != '^' && pattern[i] != '~') i++;
            var baseRef = pattern[start..i];
            if (string.IsNullOrEmpty(baseRef))
                throw new ArgumentException("BaseRef cannot be empty");

            var modifiers = new List<IRevisionModifier>();

            while (i < len)
            {
                char c = pattern[i++];
                if (c == '~')
                {
                    // odczytaj liczbę (może być wielocyfrowa) lub domyślnie 1
                    int num = ReadNumber(pattern, ref i);
                    if (num < 0) num = 1;
                    modifiers.Add(new AncestorCountModifier(num));
                }
                else if (c == '^')
                {
                    int num = ReadNumber(pattern, ref i);
                    if (num < 0) num = 1;
                    modifiers.Add(new ParentIndexModifier(num));
                }
                else
                {
                    throw new ArgumentException($"Invalid modifier symbol '{c}' in pattern");
                }
            }

            return new Revision(baseRef, modifiers);
        }

        // Helper: odczytuje liczbę począwszy od index i; jeśli brak cyfry zwraca -1 i nie przesuwa i.
        private static int ReadNumber(string s, ref int i)
        {
            int len = s.Length;
            if (i >= len || !char.IsDigit(s[i]))
                return -1;

            int start = i;
            while (i < len && char.IsDigit(s[i])) i++;
            var numStr = s[start..i];
            return int.Parse(numStr);
        }
    }

    // Przykład użycia
    class Program
    {
        static void Main()
        {
            var repo = new Repository();

            // tworzymy przykładowe commity (hashy proste dla czytelności)
            // commit graph:
            // A <- B <- C <- D
            //       \ 
            //        E (merge parent of C)
            // F <- G (innej gałęzi)
            repo.Objects["A"] = new Commit("A"); // root
            repo.Objects["B"] = new Commit("B", new[] { "A" });
            repo.Objects["E"] = new Commit("E", new[] { "B" });
            repo.Objects["C"] = new Commit("C", new[] { "B", "E" }); // C ma dwóch rodziców: B (pierwszy), E (drugi)
            repo.Objects["D"] = new Commit("D", new[] { "C" });

            repo.Objects["F"] = new Commit("F");
            repo.Objects["G"] = new Commit("G", new[] { "F" });

            // gałęzie
            repo.Branches["master"] = "D";
            repo.Branches["feature"] = "G";

            // HEAD wskazuje na master
            repo.HEAD = "D";

            // --- Przykłady działania ---

            Console.WriteLine("TraverseBranchByFirstParent starting from HEAD:");
            foreach (var c in repo.TraverseBranchByFirstParent(null))
            {
                Console.WriteLine(c.Hash);
            }
            // oczekiwane: D, C, B, A

            Console.WriteLine();
            // Przykłady wzorców:
            DisplayTraverse(repo, "HEAD");         // D
            DisplayTraverse(repo, "HEAD~1");      // C
            DisplayTraverse(repo, "HEAD~2");      // B
            DisplayTraverse(repo, "master~3");    // A
            DisplayTraverse(repo, "master^");     // C (pierwszy rodzic)
            DisplayTraverse(repo, "master^2");    // Błędne wg naszego grafu? master->D^2 => D ma tylko 1 rodzica => wyjątek
            // Przykład z merge: C^2 -> E
            DisplayTraverse(repo, "C^2");
            // Złożony: HEAD~1^2 -> C~1^2  => weź HEAD~1 = C, C^2 = drugi rodzic E
            DisplayTraverse(repo, "HEAD~1^2");
            // Łańcuch: HEAD~1^2~1  => (HEAD~1) = C, ^2 -> E, ~1 -> B
            DisplayTraverse(repo, "HEAD~1^2~1");
        }

        static void DisplayTraverse(Repository repo, string pattern)
        {
            try
            {
                Console.Write($"{pattern} -> ");
                var commits = repo.TraverseByRevision(pattern).ToList();
                Console.WriteLine(string.Join(", ", commits.Select(c => c.Hash)));
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ERROR: {ex.Message}");
            }
        }
    }
}
